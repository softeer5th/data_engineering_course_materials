## 1/13 회고

### 오늘 한 일 + 개념 정리
- W2M1 ~ W2M4 미션 수행
- multiprocessing.Pool
    - multiprocessing 모듈에서 제공하는 고수준의 병렬 처리 인터페이스
    - 여러 작업을 동시에 수행할 수 있도록 Worker 풀을 생성하고 관리
    - 프로세스를 직접 생성하고 관리하는 번거로움을 줄여줌.
    - 주요 개념
        - pool : worker를 미리 만들어 관리하는 컨테이너
    - 주요 메서드
        - Pool.map(func, iterable) : 동기적으로 실행되고, 결과는 입력 순서와 동일
        - Pool.apply(func, args=(), kwargs={}) : 하나의 작업을 동기적으로 실행하고 결과 반환
        - Pool.apply_async(func, args=(), kwargs={}) : 하나의 작업을 비동기적으로 실행하고, 즉시 반환되는 AsyncResult 객체를 사용하여 결과 비동기 수집 가능
        - Pool.starmap(func, iterable) : map과 유사하지만 함수에 여러 인수 전달 가능. 입력은 (인수1, 인수2, …) 형태의 튜플로 구성되어야 함.
    - 장점
        - 단순한 병렬 작업 관리
        - 작업자 수 조정 가능
    - 단점
        - 프로세스 생성 비용이 높음
- multiprocessing.Process
    - 새로운 프로세스를 생성하고 실행하기 위한 기본 단위
    - 독립적인 실행 흐름(프로세스)을 생성하며, 각각의 프로세스는 독립된 메모리 공간을 가지고 실행됨.
    - 고유한 메모리 공간을 사용하므로, 한 프로세스의 변화가 다른 프로세스에 영향을 미치지 않음.
    - Process 클래스의 주요 매개변수
        - target : 프로세스에서 실행할 함수를 지정
        - args : target 함수에 전달할 인수를 튜플로 지정
        - kwargs : target 함수에 전달할 키워드 인수를 딕셔너리로 지정
        - name : 프로세스의 이름을 설정. 기본값은 Process-N
        - daemon : 프로세스를 데몬 프로세스로 설정. 데몬 프로세스는 메인 프로세스가 종료되면 즉시 종료됨. 백그라운드에서 실행되는 작업(로그 기록, 데이터 정리)을 수행하는데 유용
    - Process 객체의 주요 메서드
        - start()
        - join() : 프로세스가 종료될 때까지 메인 프로세스가 대기
        - terminate() : 프로세스 강제로 종료
        - is_alive() : 프로세스가 현재 실행 중인지 T/F
- multiprocessing.Queue
    - 프로세스 간 통신을 위한 안전한 FIFO 방식의 데이터 구조
    - 동시 접근 문제를 방지하기 위해 내부적으로 락과 세마포어를 사용하여 동기화를 보장함.
    - 따라서 여러 프로세스가 동시에 큐에 접근해도 안전하게 데이터를 넣고 가져올 수 있음.
    - Queue의 동작 원리
        - 프로세스 간 데이터 통신
            - queue는 데이터를 생산자-소비자 패턴으로 처리함.
            - 하나의 프로세스가 데이터를 put하면, 다른 프로세스가 이를 꺼내 get 할 수 있음.
        - 락 & 세마포어
            - 락 : 여러 프로세스가 큐에 동시에 접근하는 것을 방지
            - 세마포어 : 큐에 남아있는 데이터 개수를 추적하여 빈 큐에서 데이터를 가져오려고 할 때 블로킹 방지
        - 직렬화
            - 큐에 데이터를 추가하기 전에 객체를 직렬화(Pickle)하여 바이트 스트림 형태로 변환한 뒤 저장
            - 데이터를 꺼낼 때는 역직렬화(Unpickle)하여 원래 객체로 복원
    - 장점
        - 안전성 : 동기화 메커니즘으로 동시 접근 문제를 방지
        - 유연성 : 데이터를 안전하게 공유하며, 멀티프로세스 환경에서 쉽게 사용 가능
        - 생산자-소비자 패턴에 적합
    - 단점
        - 성능 오버헤드 : 락과 직렬화로 인해 작은 데이터 처리에서는 성능 손실이 있을 수 있음
        - 정확한 상태 확인 어려움 : empty()와 qsize()의 불확실성을 염두해야 함.

### Keep

팀원들끼리 과제 내용에 대해서만 소통해오다가, 이번에는 multiprocessing 모듈에 관련한 내용을 추가적으로 더 학습하고 각자 조사한 내용에 대해 공유를 하는 시간을 가졌는데 도움이 많이 되었다.

### Problem

공식문서를 읽어보면서 코드 개발을 진행해보려 했는데, 공식문서를 읽는데 시간을 너무 많이 할애한 감이 있었다.

### Try

미션을 수행할 때 초반 코드 개발에 있어서는 chatGPT나 코파일럿을 사용하고 후반부 코드 디테일을 만지는 작업에서 공식문서를 활용하면 좋을 것 같다는 생각을 했다.