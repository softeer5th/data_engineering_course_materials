## 리뷰
  ### 데일리 스크럼
  
  * 오늘 할 일: M5 코드 리팩토링 및 추가학습과제

### AWS
>  hibernate 사용 시에는 램 크기 만큼 스왑 메모리 추가
>
>  램 2GB 이하 -> 스왑 메모리 2배 이상 
>  램
>  램 8GB 이상 -> 스왑 메모리 1배
>
>  램 8GB - 64GB 이상 -> 4GB - 스왑 메모리 0.5배
>
>  출처:https://opensource.com/article/19/2/swap-space-poll#
>
>  ec2에서 top 명령어를 실행하면 vCPU의 가상화된 cpu 자원의 사용률을 보여준다.
>
>  이유: ec2의 하이퍼바이저가 각 ec2 인스턴스를 격리하기 때문.
>
>  프리티어로 사용하려면 스왑 메모리를 사용해야 한다.

### W2M5 추가학습거리:

### 소셜 미디어 데이터로 감성 분석하여 선거 결과 예측하기

- micro-blog라고 하는 소셜 미디어 데이터를 사용. 전통적인 출구조사, 사전투표, 전문가 예측 등을 사용하지 않고 twitter 데이터를 사용함.

- 2019 AP 의회 선거에서 1, 2, 3순위 정당의 의석수를 정치적 점수를 사용하여 예측함. SVM 모델을 사용하였고, precision이 94.2%가 나옴.

- 총 7500개의 데이터셋을 사용함.

- 이 후 확장하여 다른 일반적인 선거에 사용도 가능함.

**소감:** 

일반적으로 전문가의 예측과 출구조사를 사용하지만, 소셜 미디어 데이터를 사용하였을 때, 더 높은 정확도를 보였다. 

그런데 왜 메타는 대통령 선거에서 공화당이 아닌 민주당을 지원한 것인지 궁금하다.

### W2M4 추가 학습:

**멀티프로세싱**

> 멀티프로세싱에서 프로세스 간 통신을 위하여 큐를 사용한다.
> 
> empty check은 non atomic한데, get과 put은 atomic하다.
> 
> 큐에서 full, empty를 사용하여 프로세스의 종료 및 시행을 제어하고, get과 put을 사용하면 에러 혹은 데드락이 발생할 수 있다 (동시성 문제로 not empty라고 판단하였는데 실제로 비어 있는 경우: 모든 라인이 get을 사용하면 큐의 데이터를 기다리면서 들어올 때 까지 그 라인에 블록되어 있다. get_nowait과 비어 있다는 에러 처리를 하지 않으면 종료되거나 다음 처리를 할 수가 없다. 이는 put도 마찬가지).
> 
> 따라서 full, empty를 사용하지 않고, get과 put으로 기다리지 않아야 한다.
> 그리고 exception handling으로 제어하는 것이 좋다.
> 
> 영구적으로 프로세스를 사용하려면 프로세스 풀을 사용한다.
> 
> 그렇다면 큐가 일종의 메세지 큐라고 하면 consumer가 고장이 나거나 consume이 되기 전에 큐가 다 차버리는 경우가 있을 수 있다. 이를 백프레셔(backpressure)라고 한다.

**해결방법**

1. consumer 스케일링
2. 큐 사이즈 늘리기
3. 프로듀서 속도 제한
4. 데드 레터 큐 (DLQ): 큐에 넣을 때 실패하면 디스크 등에 존재하는 큐에 넣어 나중에 처리한다.
5. TTL(Time To Live): 큐에 넣을 때 시간을 설정하여 일정 시간이 지나면 큐에서 삭제한다.

---

Spark streaming: 마이크로 배치 처리를 위한 스트리밍 처리 엔진. 스트리밍 데이터를 배치 처리로 변환하여 처리한다.

Flink: 스트리밍 처리 엔진. 실시간 스트림 처리를 지원한다.

---

**오늘 강의 정리:**

- 현재 컨디션에 따라 의사결정이 달라지기 때문에, 컨디션을 말하고 회의를 하는 경우도 있다.
- 주석 속에 비문 등 제거 -> chatgpt로 수정하기

**ETL**
- ETL 과정마다 사용하는 리소스가 다르다 -> 이에 따라 다른 인프라를 사용해야 한다.
- Extract는 네트워크 리소스를 많이 사용하고, cpu와 램 리소스를 적게 사용한다.
- Transform은 cpu와 램 리소스를 많이 사용한다.
- Load는 네트워크 리소스를 많이 사용하고, cpu와 램 리소스를 적게 사용한다.

**Pandas**
- 데이터 transform 시에 pandas를 최대한 사용하자
- map, apply, loop 보다는 merge, join 등을 최대한 사용하여 속도를 올리자

**코드 가독성**
- 코드를 작성할 때, 처음 보는 사람이 문제를 해결하려 보려고 한다고 가정하고 작성하자
- 내가 코드를 모르는 사람이라면 어떤 것부터 궁금해할까? 그 사람이 이해하기 쉽게 코드를 작성해보자
- 함수의 input 예시, output 예시를 주석으로 달아놓자
- try-except에서 범위를 좁게하고, exception마다 다른 에러 메세지를 출력하자


### Linux & Docker 
> docker buildx build에서 .에 .dockerignore 파일이 있어야 한다
> 
> apt-get update: 최신 패키지 리스트 업데이트. 업데이트 된 리스트는 /var/lib/apt/lists에 저장
> 
> apt-get upgrade: 실질적으로 패키지 업그레이드
> 
> build-essential: c, c++ 컴파일러, 빌드 도구 등을 설치함. gcc를 설치하기 위해 필요
> 
> OCI(Open Container Initiative): 컨테이너 이미지와 런타임을 표준화하기 위한 오픈소스 프로젝트
이 표준에 따라 컨테이너 레지스트리들이 비슷한 압축 및 최적화 메커니즘을 사용함
>
> 1. 레이어 중복 제거
> 2. 이미지 압축 (소스코드 등 텍스트)
> 3. 공유 레이어 캐싱

**Docker tip!**
- 디버깅 시에 그냥 베이스 이미지를 띄워놓고, RUN, CMD 등을 실행하여 Dockerfile 디버깅을 하자
- docker는 일종의 작은 vm os이다(Linux container runtime 참고)

**Word Cloud**
- 보고 싶은 이유를 확실히 정의해야 한다. 그렇지 않으면 결과물 자체가 좋지 않다.
- 사람의 인지적 특성, 색상 등도 고려 대상이 될 수 있다.
- 다른 데이터와 같이 사용하여 레벨 별 분석을 할 수 있다. (ex. 여자와 남자의 차이)

**Prototype**
- Agile하게 data product를 만드는 방법이 prototype이다.
- 빠르게 만들어보고, 구체적인 타겟을 잡고, 사용자 피드백을 받아 수정하는 방식이다.
- 좁게, 구체적으로 시작해야만 한다.
- 숫자를 찍어서 이를 근거로 피드백을 반영해야 한다

## 오늘의 인상 깊은 문구

### 문제 정의는 “누구”의 “어떤” 문제.

### 잘못 코드를 작성했다는 것을 뒤늦게 알았을 떄 -> 내가 왜 그렇게 의사결정을 했는지 회고 필요.

### 추가 학습 기회는 많은 실수를 할 수 있는, 내 결함을 내보일 수 있는 환경에서 나온다.

---

### Keep:계속 유지
  - 코드 리뷰 과정 중에 같이 더 나은 방법을 찾아보자

---

### Problem: 문제가 발생한 행동
  - 진정으로 지난 개발 과정에서 프로토타이핑으로 했는가 계속 생각하자
  - 배우거나 추가할 점이 있으면 그냥 주석으로 적어두고 일단 프로토타이핑을 하자
  - 돌아는 가게까지만 일단 하고 피드백을 받자

---
### Try: 다음 번에 새롭게 시도했으면 좋을 행동
  - 좁게 예시를 들고, 좁게 타겟을 잡고, 빠르게 프로토타이핑을 하자