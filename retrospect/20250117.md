## 리뷰
  ### 데일리 스크럼
  
  * 오늘 할 일: 
      1. W1M3 리팩토링 (O)
      2. W2M6 스왑메모리 추가 (X)
      3. M5 진행 (X)
      + 멀티프로세싱 문제 해결 (O)  


### **W1M3 리팩토링**
- etl_project_gdp.py 파일을 리팩토링하고, pandas를 활용한 transform 처리도 추가
- analyzer 모듈을 추가하고, 데이터를 분석하는 로직 추가


### W2M4 추가 학습 (문제 발생):

**멀티프로세싱**

큰 값을 넣어 프로세싱할 때, 문제가 발생했다.

**다른 프로세스들이 죽는 경우:**

1. exception Empty는 get_nowait()를 사용할 때 **read lock을 획득하지 못할 때에도 발생한다**.
   -> 이를 empty()와 더불어 확인할 수 있다.

   empty()는 _poll을 사용하여 큐의 내부인 Pipe의 소켓을 확인하는 것이다.
   put은 내부적으로는 _buffer가 있고,Queue의 **피더 스레드**는 계속 이것을 확인하며 Pipe의 write 소켓에 작성한다.
   이 _buffer에서 pipe로 가는 과정 중에 있다면 empty()로 확인할 수 없기에 신뢰할 수 없다는 것이다.

**프로세스 join() 시에 데드락이 발생하는 경우:**

2. Queue 내부의 Pipe의 최대 크기는 생각보다 작다. 그래서 내부 버퍼는 있지만 Pipe가 꽉 차 있을 때 계속 write를 하려고 하는 스레드 때문에 join()을 사용하면 데드락이 발생한다.
  -> 따라서 Queue를 사용할 때는 빠르게 비워줘야 한다

**편리한 방법: Manager()로 만든 Queue를 사용하면 된다.**

---

### Keep:계속 유지
  - 로우 레벨과 파이썬 구현까지 생각하며 코드 에러의 원인을 알 수 있었다

---

### Problem: 문제가 발생한 행동
  - 멀티프로세싱을 공부하느라 오늘 할 일을 다 못했는데, 이런 경우가 종종 발생한다

---
### Try: 다음 번에 새롭게 시도했으면 좋을 행동
  - 진짜 끝까지 이해하지 못한 부분이 있었는데, 추가로 나중에 해결하자