## 리뷰
  ### 데일리 스크럼
  
  **어제 배운 것:**
  
  **선우님:**
  
  **채연:**
  
  **오늘 할 일:**
  * Hadoop, MapReduce 이해: (I)
  * M3: (X)

  **한 일**
  * Hadoop 구조 이해하기
  * 문제 상황 정의
  * 문제 상황 피드백 받기
  * 일정 산출, 프로토타이핑 방법 등 고민하기

### Hadoop 시나리오
1. YARN 클라이언트가 잡, 애플리케이션 등을 RM에게 제출한다 
2. (master node의) Application Manager는 job 유효성만 체크하고, scheduler에게 job을 제출한다
3. 스케줄러는 Application Master를 실행할 임의의 slave node를 찾고, 이를 실행한다
  - 스케줄러 Policy: Capacity - 각 작업 큐 별 최대 용량을 설정해놓는다 (마케팅: 70%, 개발: 30%), Fair - 모든 작업이 동일한 우선순위를 갖는다 (독점이 없다)
  - 스케줄러의 로컬리티 vs 자원 가용성 설정: yarn.scheduler.capacity.node-locality-delay=40 (같은 노드를 포기하고, 같은 랙으로 넘어가기 위한 최대 시도 횟수) 
  - yarn.scheduler.capacity.rack-locality-additional-delay=-1 (랙 local을 포기하고 다른 랙으로 넘어가기 위한 최대 시도 횟수: L * C / N.) 
  - 예시:
    클러스터 크기 N = 100개 노드
    요청 컨테이너 수 C = 10개
    로컬리티 위치 수 L = 5개 (예: /rack1 내 5개 노드)
    계산값: 5 * 10 / 100 = 0.5 → 1회 (소수점 이하 반올림).
    따라서, 랙 로컬리티를 포기하고 다른 랙으로 넘어가기 위한 최대 시도 횟수는 1회이다.
  - job을 제출할 때의 차원에서 off-rack을 사용하지 못하게 막는 방법은 없다.
  
4. Application Master는 데이터 위치 정보(클라이언트에게 입력 데이터의 추상화된 HDFS 블록 위치를 전달받음. 실제는 RM이 HDFS API에게 요청함)를 RM에게 힌트로 전달하고, 요구사항 (CPU/메모리)도 지정한다. 이를 기반으로 RM은 최적의 노드에 컨테이너를 할당한다
   - 일단 RM이 블록 정보를 받지만 그대로 AM에게 상속시켜 그것에 대한 처리는 AM이 하도록 일이 명확히 분리되어 있다.
5. RM은 리소스를 할당하고, AM에게 node와 랙 정보만을 전달한다.
6. AM은 RM에게 컨테이너를 요청하며, RM은 이 요청을 NM에게 중개한다.
7. NM은 컨테이너를 실행하고, RM을 중개하여 AM에게 컨테이너의 상태를 전달한다
   - 이 중개 과정을 없애고 직접 통신하게 하는 프레임워크도 있다.
8. slave node에서 이상이 생긴 경우에 RM은 AM이 프로세스를 완료할 수 있도록 새로운 컨테이너를 할당한다.
   - slave node 장애: 블록이 손실되어도, 다른 노드에 복제되어 있기 때문에 문제가 없다.
   - name node가 다른 slave node에게 블록을 복제하라고 요청한다.

### HDFS와 YARN 간의 레이어 차이
- HDFS: 스토리지 레이어. namenode, datanode로 구성
- YARN: 리소스 관리 레이어. resource manager, node manager로 구성
- 현재는 namenode에 RM이 포함되어 있고, datanode에 NM가 포함되어 있어서 혼용을 하였다.
- 엄밀히 말하면 HDFS와 YARN은 별개의 레이어로, 서로 다른 개념이다.

### hadoop config 변경 시나리오
1. fs.defaultFS: 새로운 네임노드. 죽었을 때 혹은 롤오버. 하위에 S3 가능
2. hadoop.tmp.dir: 다 차는 상황 자주 발생.
3. io.file.buffer.size: 디폴트 4KB. 128KB로 변경하면 성능 향상. 개별 파일이 크면 높이는 것이 좋음.
4. dfs.replication: 파일이 중요한 경우. HA 보장.
5. dfs.blocksize: 크면 네임노드가 메타데이터 관리에 용이함. 파일 크기가 작은 것이 많다면 스토리지 손해. 즉, 아예 다른 클러스터로 분리하는 것도 고려.
6. dfs.namenode.name.dir: 이게 다 차면 큰일나기에 RAID 등 도입 필요. 미리 replication을 높여놓는 것도 방법.
7. 네임노드 혹은 데이터노드의 특정 디스크 I/O가 너무 높으면, 해당 디스크를 다른 디스크로 업그레이드하는 것도 방법.
8. yarn.nodemanager.resource.memory-mb: 슬레이브 노드의 job 관련 총 메모리 최대치 설정량.
9. Rack 여러 개 만드는 이유: 네트워크 과부하 등


---

### Keep:계속 유지
  - 아이디어의 갈피를 못잡거나 어려우면 도움을 요청하자
  - 실제 운영적인 측면 및 시나리오를 고려하자
  - 아이디어와 프로토타이핑 방법론을 같이 제시하는 것도 좋은 방법이다.
  - 프로토타입
  ```bash
  1. 트럼프가 홍준표를 샤라웃한 시간 체크하기 (뉴스 시간? 아니면 실제 시간 기준?)
  2.  홍준표랑 친하거나 대학 동기, 고등학교 인물 중 CEO나 지분 많은 사람 찾기.
  3. 그 회사 주식이 샤라웃한 시간보다 얼마나 차이가 나는지 확인하기.
  4. 주식이 얼마나 올랐는지, 그리고 몇 개의 주식 중 어떤 것이 올랐는지에 대한 비율 확인하기. 
  ```

---

### Problem: 문제가 발생한 행동
  - X

---
### Try: 다음 번에 새롭게 시도했으면 좋을 행동
  - 프로토타이핑을 하는 것으로 주제를 선정하자.