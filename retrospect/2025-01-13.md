# 2025-01-13 (2주차 월요일) 회고

## Review

> * Dano Lee 강사님이 오셔서 3번째 강의를 진행하였다.
>   * Big Data, Fault Tolerance, 멀티 프로세싱/스레딩, VM, Docker.. 등에 대해 배웠다. (물론 더 많은 내용을 배웠지만 간단히 요약함)

Spark, Hadoop을 배우게 될텐데 그러한 툴이 왜 만들어졌는지를 잘 생각해봐야 한다고 하셨다.
* 비단 위 툴 뿐 아니라 무언가를 처음 배울 때 어떤 마음가짐으로 학습을 해나가야 할지에 대한 답이 될 수 있을 것 같다.

멀티 프로세싱/멀티 스레딩을 적절히 선택해야 한다.
* W1 미션을 진행할 때 API 호출 결과를 저장하는 Extract 과정을 멀티 프로세싱으로 구현했는데.. 멀티 스레딩을 썼어야 했나?
  * 사실 막연히 뭔가 컴퓨팅 과정이 있을 수 있지 않나? 라는 생각에 일단 멀티 프로세싱으로 구현하긴 했었다.
  * 파이썬의 경우 GIL이라는 특성 때문에 라이브러리에 대한 정확한 이해와 사용이 필요한 것 같다.
    * 문득 든 생각인데 파이썬 이외의 언어를 이용할 때는 CPU bound 작업에도 멀티 스레딩을 써도 되는 것 아닌가? (집에 가서 검색해보자)
  * 뭔가 어떤 게 성능이 더 좋을까를 고민할 때.. 머릿속으로 생각하는 시간이 길어지면 탁상공론이 되는 것 같음.
    * 프로파일링을 할 수 있는 도구가 무엇이 있을지 찾아보자. 간단한 코드를 작성할 때도 편리하게 직접 눈으로 성능과 관련된 지표를 확인할 수 있도록 익혀야겠다.
  
일의 긴급도/중요도를 잘 파악하여 우선순위를 정해야 한다.
* 이번 부트캠프를 진행하면서도 시간이 부족할 때 위 말씀을 토대로 과감히 판단을 내려야겠다.

> * 2주차 미션 1 ~ 4를 진행하였다.

단일 프로세스만을 사용하는 코드에서 multiprocessing.Queue에 put을 한 뒤 pop을 하는데 Queue.empty가 (원소가 들어있음에도 불구하고) 조기에 True를 반환하는 일이 발생했다.
왜 이런 일이 생긴 건지 이해가 되지 않아서 찾아 보았는데, 마땅한 정답을 얻을 수 없었다. 오늘 집에 가서 계속 찾아봐야겠다.

* 라이브러리 코드를 확인해 보니 multiprocessing.Queue는 내부적으로 pipe를 이용하여 IPC를 지원하는데, pipe에 read/write 연산을 하는 별도의 데몬 스레드(QueueFeederThread)가 존재했다.
  * 즉 내가 작성한 코드를 실행하는 메인 스레드는 buffer에 원소를 넣고 단지 데몬 스레드에 notify를 할 뿐이었다.
  * 그래서 put을 여러 번 호출했지만 아직 pipe에는 반영이 되지 않아 간헐적으로 empty의 호출 결과가 True로 나타난 것이다.
  * 다만 qsize는 항상 정확한 숫자를 반환했는데(Mac OS에서는 실행이 안 되지만 Windows 환경에서는 잘 실행되었다), 이유는 다음과 같다.
    * qsize는 `self._maxsize - self._sem._semlock._get_value()`의 값을 반환하고, 보다시피 semaphore를 통해 원소의 개수를 계산한다. 
    * 이 semaphore는 put 호출 시 갱신이 되기 때문에 결국 put을 호출한 횟수 만큼의 값을 잘 반환한 것이다.
  * 그렇다면 empty는 왜 semaphore를 통해 개수를 판단하지 않은 것일까? (empty는 내부적으로 `poll`을 호출하여 pipe가 비어있는지 직접적으로 확인하는 듯 하다.)
    * qsize와 empty 모두 공식 문서에서는 '신뢰할 수 없다'라고 나와있지만, 그 이유는 이후의 put 혹은 get의 호출 사이에서 다른 스레드가 큐를 사용할 수 있기에 그렇게 표현한 것 같다.
    * 이 질문에 대한 답은 더 고민해봐야겠다.

Copilot을 웬만하면 끈 상태에서 코드를 작성하고 있다.
  * 아직은 반복적 코드를 빠르게 작성해내는 것이 필요한 단계가 아닌 것 같아서 그렇게 하였다.
    * 오히려 AI가 짜준 코드의 의미를 해석하는 게 생각보다 비생산적인 일이었다는 것을 알게 되었다.
  * 물론 함수에 주석을 다는 일 등에는 Copilot을 요긴하게 사용 중이다.

## Keep

* 학습을 위해 AI를 적절히 이용하기
* 문제가 생겼을 때 주변 사람과의 적극적인 대화를 통해 해결하기 (물론 그렇게 하는 것이 더 효율적일 때)
* 코드를 무작정 작성하는 것이 아니라 작성 전 요구사항을 한번 정리하여 전체적인 구조 파악하기

## Problem

* 지난 회고에 적었던 Try를 시도하지 못했다.
  * 지난 Try: Git을 활용하여 local 환경에서 부담없이 임시로 코드를 저장할 가장 좋은 방법을 찾아봐야겠다.

## Try

* 집에 가서 놀지 말고 최소한 Review를 하는 시간을 필수적으로 갖기
  * 혹은 일일 프로세스에 지난 날의 Try 사항을 확인한 후 행동으로 옮기는 과정을 추가하기